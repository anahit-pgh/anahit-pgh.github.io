<!DOCTYPE html>
<html>
    <head>
         <meta charset="utf-8" />
         <title> ISN Jules </title>
	     <link rel="stylesheet" href="style.css" />
    
</head>
	<body class="accueil">
		<h4 class="projet_titre">Notre projet de NSI : Jeu du morpion</h4>
		<p class="projet_sous_titre">I - Le jeu de Tic-Tac-Toe</p>
		<p class="projet_corps">Le Tic-Tac-Toe est un jeu de réflexion se pratiquant à deux joueurs au tour par tour et dont le but est de créer le premier un alignement. Le jeu se joue généralement avec papier et crayon mais existe de nos jours en version numérique.Ce jeu est souvent appelé Morpion, ce qui entraîne une confusion avec le jeu de Morpion qui lui ressemble par ses mécanismes mais dont le but est de former des lignes de cinq et non de trois sur un espace quadrillé. Le Tic-Tac- Toe, lui, se joue sur une grille carrée de 3 cases par 3 cases. Deux joueurs s’affrontent et doivent remplir chacun à leurtour une case de la grille avec le symbole qui leur est attribué : O ou X. Le gagnant est celui qui arrive à aligner trois symboles identiques, horizontalement, verticalement ou en diagonale, le premier.La simplicité de Tic-Tac-Toe est idéale comme un outil pédagogique pour l'enseignement des concepts de la gymnastique d’esprit ou de l'intelligence artificielle. Il est néanmoins difficile d'écrire un programme d'ordinateur pour jouer Tic-Tac-Toe parfaitement car il s’agirait d'énumérer les 765 postes essentiellement différents, ou les 26 830 jeux possibles jusqu'à ce que les 9 cases soient pleines.Pour notre Projet d’ISN, nous avons donc décidé de créer un Jeu de Tic-Tac-Toe codé en Python, avec une interface graphique, un score pour chaque joueur et éventuellement un ordinateur contre qui jouer, avec une stratégie de jeu (à notre niveau et non pas couvrant les 26 830 cas possibles) pour rendre le jeu plus attrayant par sa difficulté.</p>
		<center><img src="projet1.png" alt="morpio" /></center>
		<p class="projet_sous_titre">II - Approche du Projet</p>
		<p class="projet_corps">Lors des premières séances, nous ne souhaitions pas partir sur un Tic-Tac-Toe pour notre projet, mais de façon plus générale sur un jeu avec une grille. Nous avons donc pensé en premier lieu à une Bataille Navale en réseau, projet ambitieux, certes, mais tout de même réalisable sur un plus long terme.Au bout de quelques jours, à force de réfléchir sur nos différentes approches de la Bataille Navale qui semblait se compliquer de plus en plus, au fur et à mesure que nous avions des idées, nous avons commencé à nous tourner vers un projet plus simple. Nous avons d’abord pensé à un « Puissance 4 », puis avons encore réduit à 3 cases par 3 la grille de jeu, pour obtenir en fin de compte un jeu de Tic-Tac-Toe.Pour créer le jeu, nous avons commencé par essayer plusieurs méthodes sans Tkinter, qui se sont avérées infructueuses. Nous avons donc, grâce à l’aide de notre professeur, commencé par établir le jeu en tant que tableau : un tableau de 3 lignes par 3 colonnes remplies de « 0 ». Puis petit à petit nous avons développé les fonctionnalités pour ajouter la possibilité au joueur de choisir la case par un simple chiffre, puis en ajoutant une variable G (ou Gagnant dans certaines fonctions) qui parcours le tableau dans le sens des lignes, des colonnes ou des diagonales pour vérifier que personne n’a encore gagné.Lorsque tout cela fut fait, nous avons commencé à nous intéresser à Tkinter que nous ne maîtrisions pas, ni moi ni mon coéquipier. Cela fait, nous avons réfléchi à une disposition pour l’affichage graphique. Voici comment il était pensé au départ. Il est d’ailleurs resté à peu de choses près sous cette forme.</p>
		<center><img src="projet2.png" alt="morpio1" /></center>
		<p class="projet_corps">Nous l’avons ainsi commencé dans cette optique. Mais l’interface graphique ne faisant pas tout. Il a donc fallu trouver un moyen d’appliquer tout notre travail à la partie que nous venions de créer. Nous avons donc décidé d’associer le tableau à la zone Canevas. Ce faisant, il a fallu créer de nombreuses fonctions et surtout de nombreuses variables associées qui nous ont pris pourtant peu de temps.Avec l’avance récupérée, nous étions prêts à faire un jeu en réseau dans lequel deux joueurs s’affronteraient. Mais, nous avons très rapidement déchantés et nous sommes tournés vers un jeu contre l’ordinateur qui possède une stratégie de jeu, qui est ce que nous présentons.</p>
		<p class="projet_sous_titre">III - Problèmes Posés</p>
		<p class="projet_corps">Lors des débuts du projet, nous avons dû nous confronter à la difficulté de la grille de la bataille navale. C’est donc pour cela que nous avons réduit à un jeu de Tic-Tac-Toe.Dans le jeu en lui-même, nous avons dû nous confronter à de nombreux petits soucis :</p>
		<ul class="projet_corps">
			<li><p>Tout d’abord, comment retracer les coordonnées dans le tableau lorsque l’on choisissait une case. Pour cela, nous avions une fonction de près de 20 lignes, qui parcourait le tableau. Mais cette solution étant longue nous avons cherché un autre moyen de rentrer ces coordonnées en demandant à l’utilisateur le numéro de la case qu’il voulait jouer, les cases étant numérotées comme ci-contre.</p>
			<center><img src="projet3.png" alt="morpio2" /></center></li>
			<li>Ensuite, pour la recherche d’une victoire ou d’une égalité, il a fallu chercher et ajouter des variables telles que G ou « sommetab ». Ces dernières nous ont permis de poser des conditions nécessaires et suffisantes à la détection d’une victoire.</li>
			<li>Ensuite, les scores nous ont largement posés problèmes. Nous les avions mis sous forme de variables qui risquaient de se confondre à la moindre erreur. De plus ces variables n’étaient contenues que dans une seule fonction nommée « gagnant_tableau ». Mais au final, elle n’affichait pas correctement les textes voulus sur la fenêtre Tkinter, mais seulement dans l’interpréteur. Nous les avons donc séparées et adaptées à Tkinter.</li>
			<li>Un autre problème particulièrement prenant s’est aussi imposé : celui de la remise à zéro et des boutons pour réinitialiser et recommencer la partie. Malgré les apparences, ces deux boutons sont tout à fait différents. L’un permet de tout réinitialiser, de la grille au score, alors que l’autre ne réinitialise que la grille pour permettre de rejouer contre le « même personnage ordinateur »</li>	
			<li>Enfin, afficher le nom du joueur ne fut pas non plus chose simple, mais nous y tenions pour ajouter un aspect encore plus ludique et réaliste au jeu. Nous avons donc créé une variable qui stocke une chaîne de caractères représentant le nom du joueur réel. Mais il nous fut impossible de la faire s’afficher à côté du score dans Tkinter jusqu’à trouver comment créer plusieurs configurations de texte, ce qui nous a énormément servi, pour cela comme pour le reste.</li>
		</ul>
		<p class="projet_sous_titre">IV - Les Principales Fonctions</p>
		<p class="projet_sous_titre">4.1 - La gestion du tableau</p>
		<p class="projet_corps">La gestion du tableau s’effectue sur plusieurs fonctions et prend une grande place dans notre programme. Le principe est que, dans le programme, le joueur voit la fenêtre Tkinter, clique, et joue. Mais derrière tout ça, l’événement du clique déclenche le remplissage du tableau par le numéro du joueur, et permet l’analyse de celui-ci par d’autres foncions pour analyser le gagnant, le score ou bien l’état de la partie.Pour faire jouer le joueur réel, il nous a fallu créer un tableau vide. La fonction position_clic permet alors d’associer à un clic de coordonnées X et Y, une variable « a » qui va permettre d’identifier les coordonnées (i, j) de la case choisie dans le tableau.</p>
		<center><img src="projet4.png" alt="morpio3" /></center>
		<p class="projet_corps">Pour ce qui est de faire jouer l’ordinateur, nous lui avons créé une stratégie de jeu, qui consiste à attaquer dès qu’il le peut, et se défendre en même temps. Cette stratégie est développée au cas par cas dans la fonction « IA_Analyse ». Celle-ci renvoie une coordonnée « i » et une coordonnée « j » qui vont être associé à la création d’un cercle sur le canvas et au remplissage du tableau. Les variables « X2 » et « Y2 » sont là pour permettre le centrage dans la case, du cercle.</p>
		<center><img src="projet5.png" alt="morpio3" /></center>
		<p class="projet_corps">Voici par exemple un morceau de la stratégie pour le premier tour. L’ordinateur choisit au hasard les coordonnées qui peuvent être (0,0) ou (0,2) ou (2,0) ou (2,2) et si la case choisie est déjà prise, il doit choisir une case au hasard et trouver ses coordonnées (i, j).</p>
		<center><img src="projet6.png" alt="morpio3" /></center>
		<p class="projet_sous_titre">4.2 – Les Réinitialisations</p>
		<p class="projet_corps">La réinitialisation a été une de nos principales occupations dans la mesure où, redémarrer le programme à chaque fois que l’on voudrait rejouer, aurait été infernal pour l’utilisateur. Nous avons donc créé deux fonctions qui sont associées à deux boutons : « recommencer » et « réinitialiser les scores ». Le principal problème est que, ces fonctions étaient presque identiques à peu de choses près, mais l’une devait réinitialiser le tableau, le canvas, et les variables de jeu, et l’autre devait en plus remettre la liste des scores à zéro. Nous avons donc fait une fonction de re-création des variables de jeu, du canvas et du tableau nommée « effacer » que nous avons appelé et complété dans la deuxième.</p>	
		<center><img src="projet7.png" alt="morpio3" /></center>
		<center><img src="projet8.png" alt="morpio3" /></center>
		<p class="projet_sous_titre">4.3 – Victoires, Gagnants et Scores</p>
		<p class="projet_corps">La détection des victoires est un des principaux atouts du jeu de morpion. Même si l’utilisateur sait lorsqu’il gagne, qu’il a gagné, un affichage de l’état du jeu est plus attrayant pour lui et par ailleurs, obligatoire pour le compteur de scores.En effet, tout le système est basé sur une variable « G » qui se modifie si trois cases alignées sont égales à 1 pour le joueur 1 ou à 2 pour l’ordinateur. Cette variable permet d’incrémenter le score de chaque joueur ou le nombre d’égalités et déclenche, en fonction de sa valeur, un affichage à côté du canvas du nombre de parties gagnées, perdues, ou égalités, ainsi que l’état de la partie (« joueur 1/ordinateur a Gagné » ou bien « Egalité »). La fonction gagnant permet d’analyser les lignes/colonnes/diagonales du Tableau pour détecter un alignement éventuel de 1 ou de 2.</p>
		<center><img src="projet9.png" alt="morpio3" /></center>
		<p class="projet_corps">La fonction texte_gagnant est associée à la fonction gagnant. Si quelqu’un gagne, le jeu se bloque depuis la fonction position_clic, et la variable G est alors retournée. C’est là que texte_gagnant intervient : elle choisit une configuration de texte à afficher en fonction du gagnant et incrémente son score en fonction de ce qu’il affiche.</p>
		<center><img src="projet10.png" alt="morpio3" /></center>
		<p class="projet_sous_titre">4.4 – L’ordinateur et sa stratégie</p>
		<p class="projet_corps">Pour que l’ordinateur ne joue pas au hasard, nous lui avons créé une stratégie. Mais en tant que débutants à qui il ne reste que deux semaines pour envoyer leur projet, nous ne pouvions pas traiter les quelques 28 000 cas existants pour la stratégie. Une stratégie complète des meilleurs coups à jouer dans chaque cas existe déjà : en voici la composition (mais il aurait été beaucoup trop long (3 000 lignes) pour nous de la retranscrire en python) :</p>
		<center><img src="projet11.png" alt="morpio3" /></center>
		<p class="projet_corps_diago">Sur ces Images, la croix Rouge ou le Rond rouge le plus grand sont ce qu’il faut jouer dans chaque cas. Pour continuer de lire la carte, il faut considérer chaque case comme une nouvelle grille dont la condition est ce qui a été joué auparavant.</p>
		<center><img src="projet12.png" alt="morpio3" /></center>
		<p class="projet_corps">Pour que l’ordinateur ne joue pas au hasard, nous lui avons créé une stratégie. Mais en tant que débutants à qui il ne reste que deux semaines pour envoyer leur projet, nous ne pouvions pas traiter les quelques 28 000 cas existants pour la stratégie. Une stratégie complète des meilleurs coups à jouer dans chaque cas existe déjà : en voici la composition (mais il aurait été beaucoup trop long (3 000 lignes) pour nous de la retranscrire en python) :</p></p>
		<center><img src="projet13.png" alt="morpio3" /></center>
		<center><img src="projet14.png" alt="morpio3" /></center>
		<p class="projet_sous_titre">4.5 – Tkinter</p>
		<p class="projet_corps">Tkinter fut la partie à la fois simple et complexe de notre projet. Il fallait touver le moyen de créer la grille, les frames et les textes variables. Nous avons donc décomposé Tkinter en 3 parties : La création de la fenêtre, la création des frames, et enfin les configurations de textes « texte.configure (text=... ».</p>
		<center><img src="projet15.png" alt="morpio3" /></center>
		<center><img src="projet16.png" alt="morpio3" /></center>
		<p class="projet_sous_titre">VI – Jeu de tests et Expansions possibles</p>
		<p class="projet_corps">Nous avons testé un très grand nombre de fois le programme (plus de 1000 fois).Nos premiers tests sur le programme presque final a été de vérifier le canvas et sa mise en place. Un simple test d’observation et correction des coordonnées.Ensuite, il a fallu tester les croix et ronds sur chaque position pour vérifier qu’elles associaient bien le tableau à la case cliquée. Après ça, nous avons testé en grand nombre de fois à cause de nombreuses erreurs, le jeu aléatoire de l’ordinateur. Ce faisant, il a fallu modifier plusieurs variables et ajouter, enlever, changer plusieurs fonctions.Ensuite, notre travail le plus long sur les tests a été de tester les fonctionnalités des boutons Réinitialiser et Recommencer, qui ont bien mis 1 semaine à marcher parfaitement. Enfin, nous avons testé la stratégie de l’ordinateur deux bonnes centaines de fois pour tester tous les cas possibles et imaginables de hasard créé par l’ordinateur. Ce fut assez soutenu parce qu’en effet, il a fallu noter tous les cas tester et vérifier chaque possibilité. Enfin grâce à ces tests, nous avons trouvé la faille possible dans la stratégie de l’ordinateur, et l’avons corrigé pour obtenir une stratégie presque infaible par un premier choix de case au hasard suivi de la stratégie de complémentarité au cas par cas.</p>	
		<center><img src="projet17.png" alt="morpio3" /></center>
		<p class="projet_corps">Des expansions possibles de ce projet, ou même de ce programme pourraient être n’importe quel jeu avec une grille jouable contre un ordinateur, comme un jeu de bataille navale. Nous pourrions également étendre les fonctions concernant le score et/ou l’affichage des frames et des boutons à n’importe quel jeu dans lequel l’utilisateur joue un grand nombre de fois.Ce programme pourrait être développé dans le but de personnaliser l’interface graphique ou bien les possibilités de jeu. Par exemple, l’utilisateur pourrait choisir son niveau de difficulté contre l’ordinateur... ou encore, on pourrait améliorer ce jeu en le mettant en réseau pour que deux utilisateurs qui se connectent sur le web puissent jouer ensemble de la même façon que nous jouons contre l’ordinateur programmé.</p>
		<p class="projet_sous_titre">VII – Bibliographie</p>
		<center><img src="projet18.png" alt="morpio3" /></center>
	<script type="text/javascript">
//<![CDATA[
if (typeof _gstat != "undefined") _gstat.audience('','pagesperso-orange.fr');
//]]>
</script>
</body>
</html>